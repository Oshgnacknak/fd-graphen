\documentclass[a4paper, ngerman]{article}

% TODO: Replace Ai with { A0, ..., An } thoughout
% TODO: Write out all Sets, ABC -> { A, B, C }

\usepackage{babel}
\usepackage{csquotes}
\usepackage{amsmath}
\usepackage{tikz}

\usetikzlibrary{graphs}

\title{Funktionelle Abhängigkeit und Graphen}
\author{Oshgnacknak}
\date{\today}

\setlength{\parindent}{0em}
\setlength{\parskip}{1em}

\begin{document}

\maketitle

Damit Datenbanksysteme Optimal arbeiten können,
müssen die in ihnen eingetragenen Daten
gewisse Eigenschaften erfüllen.
Für die Analyse dieser Eigenschaften
Sind funktionelle Abhängigkeiten essentiell.

Wir wollen uns im weiteren Verlauf dieses Dokuments damit befassen,
wie man funktionelle Abhängigkeiten durch Graphen ausdrücken
und mit ihnen arbeiten kann.

\section*{Funktionelle Abhängigkeiten}
Eine funktionelle Abhängigkeit
(im Folgenden nur noch \enquote{FD}, für \emph{functional dependency})
ist eine Relation zwischen zwei Attributmengen.
Nämlich die \enquote{folgt aus} Beziehung:
Wir schreiben
$$
    A_0, \dots, A_n \to 
    B_0, \dots, B_m
$$
wenn in einer Tabelle (Relation) alle Zeilen (Tupel),
die in den Spalten (Attributen) $A_i$ übereinstimmen
auch in den Spalten $B_i$ übereinstimmen.

Als Beispiel soll folgende Tabelle dienen:
\begin{center}
\begin{tabular}{ c | c | c }
    Straße & PLZ & Ort \\
    \hline
    Heinertstraße & 37308 & Wingerode \\
    Hatter Straße & 37308 & Wingerode \\
    Hohenwestedter & 88499 & Emeringen \\
    Neubanz & 88500 & Emeringen \\
    Heinertstraße & 56283 & Beulich \\
\end{tabular}
\end{center}
Kennt man die PLZ, ist auch der Ort eindeutig
$$
    \text{PLZ} \to \text{Ort}
$$
Kennt man wiederrum den Ort und die Straße,
kann man auf die PLZ zurück schließen
$$
    \text{Straße}, \text{Ort} \to \text{PLZ}
$$

\section*{Eigenschaften funktioneller Abhängigkeit}
Um uns klar zu machen,
warum gerade Graphen eine gute Darstellung für
funktionelle Abhängigkeiten sind,
wollen wir ein paar Überlegungen zu FDs machen.

\subsection*{Reflexivität}
Eine Relation ist reflexiv,
wenn jeder Wert mit sich selbst in einer Beziehung steht.
Das ist bei FDs natürlich der Fall,
denn wenn die Spalten $A_i$ festgelegt wurden,
sind insbesondere die Werte $A_i$ bestimmt.
$$
    A_i \to A_i
$$

\subsection*{Transitivität}
Eine Relation ist transitiv,
wenn sich die Relation zwischen mehreren Werten überträgt.
Also wenn aus $A_i \to B_i$ und $B_i \to C_i$ schon $A_i \to C_i$ folgt.

Für FDs ist auch dies keine schwere Überlegung,
denn wenn die Werte $A_i$ feststehen,
folgen daraus die Werte für $B_i$,
wonach wir aber auch eindeutige Werte für $C_i$ bekommen.

Es ist uns somit erlaubt,
\enquote{$\to$} zu verketten,
was wir für Graphen unbedingt brauchen
$$
    A_i \to B_i \to C_i
$$

\subsection*{Teilmengen}
Reflexivität ist nur ein Sonderfall hier von,
aber ich wollte es explizit erwähnen.
Die Idee ist, wenn wir die Werte $A_i$ festlegen,
und dann eine Teilmenge $B \subseteq A$ davon auswählen.
Bleiben die Werte gleich.
$$
    A_i \to B_i
$$

Das erlaubt uns insbesondere,
FDs aufzuteilen, sodass die rechte Seite
immer nur genau ein Element hat.
Anstatt $ABC \to DEF$ können wir also
$$
    ABC \to D,\;
    ABC \to E,\;
    ABC \to F
$$
schreiben, solange wir alle drei FDs hinschreiben.
Das ist auch wichtig, denn eine Kante
in einem Graph hat immer genau einen Zielknoten.

\section*{Funktionelle Abhängigkeiten als Graphen}
Zur einer gegebenen Menge an FDs können
wir uns nun endlich überlegen,
wie deren Graph aus zu stehen hat.

Zunächst bekommt jede Attributmenge
auf der Linken Seite einen Knoten,
der mit der Menge selbst beschriftet ist.
Sind z.B. die FDs
$$
    AB \to C,\;
    CD \to E,\;
    EF \to AGH
$$
gegeben, brauchen die Knoten $AB$, $CD$ und $EF$.
\begin{center}
    \tikz{
        % \node[] (a) at (0,0) {$A$};
        \node[] (ab) at (1,0) {$AB$};
        % \node[] (b) at (1,-1) {$B$};
        % \node[] (c) at (1,-2) {$C$};
        \node[] (cd) at (1,-3) {$CD$};
        % \node[] (d) at (0,-3) {$D$};
        % \node[] (e) at (-1,-3) {$E$};
        \node[] (ef) at (-2,-3) {$EF$};
        % \node[] (f) at (-2,-2) {$F$};
        % \node[] (g) at (-2,-1) {$G$};
        % \node[] (h) at (-2,0) {$H$};

        \graph{
            % (ab) -> (a);
            % (ab) -> (b);
            % (ab) ->[bend left] (c);

            % (cd) -> (c);
            % (cd) -> (d);
            % (cd) ->[bend left] (e);

            % (ef) -> (e);
            % (ef) -> (f);
            % (ef) ->[bend left] (g);
            % (ef) ->[bend left] (h);
            % (ef) -> (a);
        }
    }
\end{center}
Für die rechten Seiten bekommt
jedes Attribute seinen eigenen Knoten.
Hier also $C$, $E$, $A$, $G$, und $H$.
Die Kanten ergeben sich eben aus den FDs.
\begin{center}
    \tikz{
        \node[] (a) at (0,0) {$A$};
        \node[] (ab) at (1,0) {$AB$};
        % \node[] (b) at (1,-1) {$B$};
        \node[] (c) at (1,-2) {$C$};
        \node[] (cd) at (1,-3) {$CD$};
        % \node[] (d) at (0,-3) {$D$};
        \node[] (e) at (-1,-3) {$E$};
        \node[] (ef) at (-2,-3) {$EF$};
        % \node[] (f) at (-2,-2) {$F$};
        \node[] (g) at (-2,-1) {$G$};
        \node[] (h) at (-2,0) {$H$};

        \graph{
            % (ab) -> (a);
            % (ab) -> (b);
            (ab) ->[bend left] (c);

            % (cd) -> (c);
            % (cd) -> (d);
            (cd) ->[bend left] (e);

            % (ef) -> (e);
            % (ef) -> (f);
            (ef) ->[bend left] (g);
            (ef) ->[bend left] (h);
            (ef) -> (a);
        }
    }
\end{center}
Wir sind aber noch nicht fertig.
Wie wir uns überlegt haben,
können wir die Attributmenge
auf der linken Seite mit in die rechte übernehmen.
$$
    A_i \to B_i \implies
    A_i \to A_i, B_i 
$$

Diese Kanten sind im späteren Verlauf
auch wichtig und wir wollen sie auch gleich einzeichnen.
\begin{center}
    \tikz{
        \node[] (a)  at (0,0)   {$A$};
        \node[] (ab) at (1,0)   {$AB$};
        \node[] (b)  at (1,-1)  {$B$};
        \node[] (c)  at (1,-2)  {$C$};
        \node[] (cd) at (1,-3)  {$CD$};
        \node[] (d)  at (0,-3)  {$D$};
        \node[] (e)  at (-1,-3) {$E$};
        \node[] (ef) at (-2,-3) {$EF$};
        \node[] (f)  at (-2,-2) {$F$};
        \node[] (g)  at (-2,-1) {$G$};
        \node[] (h)  at (-2,0)  {$H$};

        \graph{
            (ab) -> (a);
            (ab) -> (b);
            (ab) ->[bend left] (c);

            (cd) -> (c);
            (cd) -> (d);
            (cd) ->[bend left] (e);

            (ef) -> (e);
            (ef) -> (f);
            (ef) ->[bend left] (g);
            (ef) ->[bend left] (h);
            (ef) -> (a);
        }
    }
\end{center}

\subsection*{Erreichbarkeit und die Hülle}
Bei FDs ist der Begriff der Attributhülle 
von großer Bedeutung.
Die Attributhülle von eine
gegebenen Attributmenge $A_i$
ist die Menge aller Attibute, 
die funktionell von $A_i$ abhängig.
Wir schreiben $A_i^+$ für die Attributhülle von $A_i$.

Wie wir sehen werden,
sind das alle Knoten in unserem Graphen,
die von $A_i^+$ aus erreichbar sind,
denn auch bei dieser Fragestellung
gilt Reflexivität und Transitivität.

Wir können uns somit für die Berechnung der Hülle
vollständig auf den Graphen konzentrieren.

Nehmen wir als Beispiel die FDs
$$
    A  \to B,\;
    AB \to C,\;
    CD \to E,\;
    EF \to AGH
$$
und bestimmen die Hülle $EF^+$ von $EF$.
Hier der Graph:
\begin{center}
    \tikz{
        \node[] (a)  at (0,0)   {$A$};
        \node[] (ab) at (1,0)   {$AB$};
        \node[] (b)  at (1,-1)  {$B$};
        \node[] (c)  at (1,-2)  {$C$};
        \node[] (cd) at (1,-3)  {$CD$};
        \node[] (d)  at (0,-3)  {$D$};
        \node[] (e)  at (-1,-3) {$E$};
        \node[] (ef) at (-2,-3) {$EF$};
        \node[] (f)  at (-2,-2) {$F$};
        \node[] (g)  at (-2,-1) {$G$};
        \node[] (h)  at (-2,0)  {$H$};

        \graph{
            (a)  -> (b);
            (ab) -> (a);
            (ab) -> (b);
            (ab) ->[bend left] (c);

            (cd) -> (c);
            (cd) -> (d);
            (cd) ->[bend left] (e);

            (ef) -> (e);
            (ef) -> (f);
            (ef) ->[bend left] (g);
            (ef) ->[bend left] (h);
            (ef) -> (a);
        }
    }
\end{center}
Zunächst gilt Reflexivität und damit
$$
    EF \subseteq EF^+
$$
In anderen Worten: $EF$ ist von sich selber aus erreichbar.

Dann können wir alle Knoten hinzunehmen,
die direkt von $EF$ aus erreichbar sind.
$$
    AGH \subseteq EF^+  
$$
Es kommen nur $AGH$ dazu.

Vom Knoten $EF$ aus können wir nichts mehr lernen,
aber wir haben festgestellt, ist $EF$ bestimmt,
dann ist auch $A$ festgelegt.
Wir können die Berechnung also mit $A$ fortsetzen.
$$
    EF^+ = EF^+ \cup A^+
$$
Hier kommt die Transitivität von FDs zu trage.

Durch $A^+$ kommt sogleich der Knoten $B$ hinzu.
$$
    B \subseteq EF^+
$$
Wir nehmen Zwischenstand und es gilt
$$
    ABEFGH \subseteq EF^+
$$
Das gibt uns, dass wenn $EF$ bestimmt ist,
auch $AB$ bestimmt fest steht.
Auch wenn hierzu noch keine Kante eingezeichnet ist,
haben wir dennoch gezeigt, dass es diese gibt
und wir können mit $AB^+$ weiter machen.
$$
    EF^+ = EF^+ \cup A^+ \cup AB^+
$$
Es kommst aber nur noch $C$ dazu.
Wir habe die Hülle bestimmt.
$$
    EF^+ = ABCEFGH
$$

\section*{Die tatsächliche Größe des Graphen}
Wie gerade gesehen haben wir nicht alle Kanten angegeben.
Tatsächlich haben wir auch nicht alle Knoten hingemalt,
z.B. der Knoten $ACE$ fehlt.
Wir müssten auch Folgendes in unserem Graphen haben.
\begin{center}
\tikz{
    \node[] (ace) at (0,0)   {$ACE$};

    \node[] (ac) at (0,1)   {$AC$};
    \node[] (ae) at (-1,-1) {$AE$};
    \node[] (ce) at (1,-1)  {$CE$};

    \node[] (a) at (-1,0)  {$A$};
    \node[] (c) at (1,0)   {$C$};
    \node[] (e) at (0,-1)  {$E$};

    \graph{
        (ace) -> (ac);
        (ace) -> (ae);
        (ace) -> (ce);

        (ace) -> (a);
        (ace) -> (c);
        (ace) -> (e);

        (ac) -> (a);
        (ac) -> (c);

        (ae) -> (a);
        (ae) -> (e);

        (ce) -> (c);
        (ce) -> (e);
    }
}
\end{center}
Das wird aber sehr schnell unübersichtlich
und deswegen verzichten wir auf
ein Großteil dieser Informationen.

Das ist aber nicht zu unserem Nachteil,
denn wenn wir später Normalisieren wollen,
werden wir feststellen,
dass wir tatsächlich noch mehr Knoten
und kanten aus unseren Graphen verbannen wollen.

Man mache sich klar, dass es zu einer 
gegebenen Attributsmenge mindestens
$2^n$ Knoten geben muss.
Es gibt dann noch weitaus mehr Kanten.

\section*{Schlüssel}
Keine Datenbank kommt ohne Schlüssel aus.
Schlüssel sind dafür relevant,
Zeilen in unseren Tabellen eindeutig zu bestimmen.

Daher die Definition:
Eine Attributmenge ist ein Schlüssel,
gdw. alle Attribute in ihrer Hülle sind.
An anderen Worten: Sind die Schlüsselwerte bestimmt,
stehen alle Werte fest.

In unseren Graphen heißt das,
Schlüssel sind alle Knoten,
von denen aus der gesamte Graph erreichbar ist.

Manche sagen nennen Schlüssel auch \enquote{Superschlüssel}.
Ich halte diesen Begriff für missverständlich,
da dies noch die schwächste Eigenschaft ist.

Ein Schlüssel heißt einfach,
gdw. er nur ein Element hat.

Z.B. ist im folgenden Graphen $A$ einfach,
$AB$ aber nicht.
\begin{center}
\tikz\graph{
    "$AB$" -> "$A$" -> {"$B$", "$C$"}
};
\end{center}
Ist ein Schlüssel nicht einfach,
ist er zusammengesetzt.
Im obigen Beispiel also der Schlüssel $AB$.

Ein Schüssel ist minimal,
wenn es keine kleineren Schlüssel
im Sinne der Teilmengenordnung \enquote{$\subseteq$} gibt.
Z.B ist hier der Schlüssel $AB$ minimal, $ABC$ aber nicht.
\begin{center}
\tikz{
    \node[] (abc) at (0,0)   {$ABC$};
    \node[] (ab)  at (1.2,0) {$AB$};
    \node[] (c)   at (0, -1) {$C$};
    \node[] (d)   at (1,-1)  {$D$};

    \graph{
        (abc) -> (ab);
        (ab) -> (c);
        (ab) -> (d);
    }
}
\end{center}

Ein Schlüssel ist trivial,
gdw. er alle Attribute in der Relation beinhaltet.
Im obigen Beispiel wäre also $ABCD$ der triviale Schlüssel.

Minimale Schlüssel sind von besonderer Bedeutung.
Daher erhalten sie eine eigenen Namen: \enquote{Schlüsselkandidat},
im Folgenden kurz SK.
Diese Bezeichnung halte ich wieder für etwas widersprüchlich,
da SKs schon Schlüssel sind -
sie müssen nicht dafür kandidieren.

Es ist daher hilfreich, sich klar zu machen,
dass \enquote{Schlüsselkandidat} wiederrum kurz
für \enquote{Primärschlüsselkandidat} ist.
Ein \enquote{Primärschlüssel},
im Folgenden kurz PK für \emph{primary key},
ist ein von uns ausgewählter SK.

Hier nochmal die Hierarchie in einer Liste:
\begin{enumerate}
    \item Normale Attributmenge
    \item Schlüssel: Attributmenge mit maximaler Hülle
    \item SK: minimaler Schlüssel ($\subseteq$)
    \item PK: Speziell ausgewählter SK
\end{enumerate}

\section*{Bestimmen der Schlüsselkandidaten}
Wir wollen uns an folgenden Beispiel anschauen,
wie man SKs aus dem Graphen zu eine FD Menge auslesen kann.
Gegeben also die FDs:
$$
    A  \to C,\;
    B  \to DE,\;
    C  \to F,\;
    F  \to G,\;
    FG \to A,\;
    E  \to G,\;
    A  \to F
$$
Und deren Graph:
\begin{center}
    \tikz{
        \node[] (a)  at (0,    0)     {$A$};
        \node[] (c)  at (0,    -1.2)  {$C$};
        \node[] (b)  at (0,    -2.4)  {$B$};
        \node[] (d)  at (-1.2, -2.4)  {$D$};
        \node[] (e)  at (-2.4, -2.4)  {$E$};
        \node[] (f)  at (-2.4, -1.2)  {$F$};
        \node[] (g)  at (-2.4, -0.0)  {$G$};
        \node[] (fg)  at (-1.2,   -0.0)  {$FG$};

        \graph{
            (a) -> (c);
            (a) -> (f);

            (b) -> (d);
            (b) ->[bend right] (e);

            (e) ->[bend left] (g);

            (f) -> (g);

            (fg) -> (f);
            (fg) -> (g);
            (fg) -> (a);
            
            (c) -> (f);
        }   
    }       
\end{center}
Bevor wir uns weitere Gedanken machen,
sollte uns zwei Dinge beim betrachten des Graphen auffallen:
\begin{enumerate}
    \item Der Knoten $B$ kann von keinem anderen Knoten erreicht werden.
        Damit muss er teil jedes SKs sein.
    \item Die Knoten $D$ und $G$ haben keine ausgehenden Kanten.
        Sie sind uninteressant.
\end{enumerate}
Wir wollen die Hülle aller noch relevanten Knoten berechnen:
\begin{align*}
    A^+ &= ACFG \\
    B^+ &= BDEG \\
    C^+ &= ACFG \\
    E^+ &= EG \\
    F^+ &= ACFG
\end{align*}
$A$, $C$ und $F$ haben die gleiche Hülle
und sind damit austauschbar.
Wir nehmen $B$ hinzu und haben
jeweils alles abgedeckt.
Es ergeben sich die SKs:
$$
    AB, CB, FB
$$


\end{document}
